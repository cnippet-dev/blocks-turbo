import path from "path";
import fs from "fs/promises";
import { styles } from "../registry/registry-styles";
import { registry } from "../registry/index";

const REGISTRY_PATH = path.join(process.cwd(), "public/r");

async function buildRegistry(registry: any) {
  let index = `// @ts-nocheck
// This file is autogenerated by scripts/create-registry.js
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {`;
  for (const style of styles) {
    for (const item of registry) {
      const resolveFiles = item.files?.map(
        (file: any) => `${typeof file === "string" ? file : file.path}`,
      );
      if (!resolveFiles) {
        continue;
      }
      const type = item.type.split(":")[1];
      let sourceFilename = "";
      let chunks: any[] = [];
      if (item.type === "registry:block") {
        sourceFilename = `__registry__/${style.name}/${type}/${item.name}.tsx`;
        if (item.files) {
          const files = item.files.map((file: any) =>
            typeof file === "string"
              ? { type: "registry:page", path: file }
              : file,
          );
          if (files?.length) {
            sourceFilename = `__registry__/${style.name}/${files[0].path}`;
          }
        }
      }
      let componentPath = `@/${type}/${item.name}`;
      if (item.files) {
        const files = item.files.map((file: any) =>
          typeof file === "string"
            ? { type: "registry:page", path: file }
            : file,
        );
        if (files?.length) {
          componentPath = `@/${files[0].path}`;
        }
      }
      index += `
  "${item.name}": {
    name: "${item.name}",
    type: "${item.type}",
    ${item.type === "registry:block"
    ? `auth: ${item.auth || false},
    pro: ${item.pro || false},`
    : `number: "${item.number || ""}",`}
    files: [${item.files?.map((file: any) => {
    const filePath = `${typeof file === "string" ? file : file.path}`
    const resolvedFilePath = path.resolve(filePath)
    return typeof file === "string"
      ? `"${resolvedFilePath}"`
      : `{ 
      path: "${filePath}",
      type: "${file.type}",
      target: "${file.target ?? ""}"
    }`
    })}],
    component: React.lazy(() => import("${componentPath}")),
  },`;
    }
  }
  index += `
}
`;

  const items = registry
    .filter((item: any) => ["registry:section"].includes(item.type))
    .map((item: any) => {
      return {
        ...item,
        files: item.files?.map((_file: any) => {
          const file =
            typeof _file === "string"
              ? {
                path: _file,
                type: item.type,
              }
              : _file;

          return file;
        }),
      };
    });
  const registryJson = JSON.stringify(items, null, 2);

  try {
    await fs.mkdir(REGISTRY_PATH, { recursive: true });

    await fs.writeFile(
      path.join(REGISTRY_PATH, "index.json"),
      registryJson,
      "utf8",
    );

    await fs.writeFile(
      path.join(process.cwd(), "__registry__/index.tsx"),
      index,
      "utf8",
    );

    console.log("âœ… Registry built successfully!");
  } catch (error) {
    console.error("Error building registry:", error);
    process.exit(1);
  }
}

buildRegistry(registry).catch((error) => {
  console.error("Failed to build registry:", error);
  process.exit(1);
});
