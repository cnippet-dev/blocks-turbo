import path from "path";
import fs from "fs/promises";
import { styles } from "../registry/registry-styles";
import { registry } from "../registry/index";
import type { RegistryItem, RegistryFile } from "../types/registry";

const REGISTRY_PATH = path.join(process.cwd(), "public/r");

// Helper function to remove file extension from import path
function removeExtension(filePath: string): string {
    return filePath.replace(/\.(tsx|ts|jsx|js)$/, "");
}

async function buildRegistry(registryItems: RegistryItem[]) {
    let index = `// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"
import type { RegistryIndex } from "@/types/registry";

export const Index: RegistryIndex = {`;
    // Loop through styles for future multi-style support
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const _style of styles) {
        for (const item of registryItems) {
            if (!item.files || item.files.length === 0) {
                continue;
            }
            const type = item.type.split(":")[1];
            let componentPath = `@/${type}/${item.name}`;
            if (item.files) {
                const files = item.files.map((file: string | RegistryFile) =>
                    typeof file === "string"
                        ? { type: "registry:page" as const, path: file }
                        : file,
                );
                if (files?.length) {
                    // Remove file extension from import path for TypeScript compatibility
                    componentPath = `@/${removeExtension(files[0].path)}`;
                }
            }
            const filesArray =
                item.files?.map((file: string | RegistryFile) => {
                    const filePath =
                        typeof file === "string" ? file : file.path;
                    if (typeof file === "string") {
                        return `"${filePath}"`;
                    }
                    return `{ 
      path: "${filePath}",
      type: "${file.type}",
      target: "${file.target ?? ""}"
    }`;
                }) || [];

            index += `
  "${item.name}": {
    name: "${item.name}",
    type: "${item.type}",
    ${
        item.type === "registry:block"
            ? `auth: ${item.auth || false},
    starter: ${item.starter || false},
    pro: ${item.pro || false},`
            : `number: "${item.number || ""}",`
    }
    files: [${filesArray.join(",")}],
    component: React.lazy(() => import("${componentPath}")),
  },`;
        }
    }
    index += `
}
`;

    const items = registryItems
        .filter((item: RegistryItem) =>
            ["registry:section"].includes(item.type),
        )
        .map((item: RegistryItem) => {
            return {
                ...item,
                files: item.files?.map((_file: string | RegistryFile) => {
                    const file: RegistryFile =
                        typeof _file === "string"
                            ? {
                                  path: _file,
                                  type: item.type,
                              }
                            : _file;

                    return file;
                }),
            };
        });
    const registryJson = JSON.stringify(items, null, 2);

    try {
        await fs.mkdir(REGISTRY_PATH, { recursive: true });

        await fs.writeFile(
            path.join(REGISTRY_PATH, "index.json"),
            registryJson,
            "utf8",
        );

        await fs.writeFile(
            path.join(process.cwd(), "__registry__/index.tsx"),
            index,
            "utf8",
        );

        console.log("âœ… Registry built successfully!");
    } catch (error) {
        console.error("Error building registry:", error);
        process.exit(1);
    }
}

buildRegistry(registry).catch((error) => {
    console.error("Failed to build registry:", error);
    process.exit(1);
});
